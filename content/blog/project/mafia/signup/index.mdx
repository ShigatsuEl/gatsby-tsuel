---
title: NestJS 회원가입 구현하기(TypeORM, + MySQL)
date: 2021-07-25
slug: /blog/project/mafia/signup
categories: ['all', 'project']
tags: ['NestJS', 'TypeScript', 'TypeORM', 'MySQL']
---

이번 글에서는 User Entity를 생성하고 회원가입을 구현하여 User Schema에 데이터를 생성하는 과정을 진행해 볼 것 입니다. 
또한 NestJS에서 제공하는 Validation을 사용해 유효성 검사를 통해 원치 않는 데이터 형태가 입력되면 에러를 발생시켜 데이터 생성을 실패하도록 만들어 봅시다.

## User Entity 생성하기

회원가입을 진행하기 위해 우리는 `User` Entity를 생성할 것 입니다. 
하지만 그 전에 모든 Entity가 필요하는 필드를 먼저 구현해 보도록 합시다.

1. nest generate

  ```shell
  nest g mo common
  ```

  위 명령어를 사용해 common 모듈을 생성합니다. 
  nest cli를 사용해 모듈을 생성하면 NestJS가 자동으로 app.module.ts에 Common 모듈을 import 해줄 것 입니다.

  다음으로 common 디렉토리에 대한 Path Alias를 지정하도록 합니다.

  ```json
  {
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@common/*": ["src/common/*"],
      "@/*": ["src/*"]
    }
  }
  ```

2. core.entity.ts 생성

  `src/common/entities/core.entity.ts`
  ```ts
  import { CreateDateColumn, Entity, PrimaryGeneratedColumn, UpdateDateColumn } from 'typeorm';

  @Entity()
  export class Core {
    @PrimaryGeneratedColumn()
    id: number;

    @CreateDateColumn()
    createdAt: Date;

    @UpdateDateColumn()
    updatedAt: Date;
  }
  ```

  Core Entity는 모든 Entity가 가지게 될 필드들로 기본적으로 id를 가지며 
  언제 생성되었느지? 그리고 언제 업데이트가 되었는지 알려주는 필드를 가집니다.

3. user.entity 생성

  3-1. nest generate

  ```shell
  nest g mo users
  ```

  3-2. user.entity.ts 생성

  ```ts
  import { Column, Entity } from 'typeorm';

  import { Core } from '@common/entities/core.entity';

  @Entity()
  export class User extends Core {
    @Column({ unique: true })
    email: string;

    @Column()
    firstName: string;

    @Column()
    lastName: string;

    @Column()
    password: string;
  }
  ```

  User Entity는 Core Entity를 extends 하므로 id, createdAt, updatedAt 필드를 가지게 됩니다. 
  그리고 eamil, firstName, lastName, password 필드도 가지며 email 필드는 중복될 수 없으므로 option으로 `unique:true`를 설정 했습니다.

## Validation Pipe

NestJS는 클라이언트로부터 받아오는 페이로드에 대해 유효성 검사를 진행할 수 있습니다. 
이것이 무슨 말인지 이해를 돕기 위해 어플리케이션에서 회원가입을 한다고 가정해봅시다. 
클라이언트가 회원가입을 진행하게 될 시, Form으로부터 여러 데이터들을 백엔드로 전송하게 됩니다. 
그리고 NestJS에서는 클라이언트에게 받은 데이터를 데이터베이스에 저장할 수 있는 데이터인지 검증할 수 있게 되는데 이것은 NestJS가 제공하는 `ValidationPipe` 덕분에 가능한 일 입니다.

1. ValidationPipe 선언

  ```ts
  import { ValidationPipe } from '@nestjs/common';
  ...

  async function bootstrap() {
    const app = await NestFactory.create(AppModule);
    // higlight-next-line
    app.useGlobalPipes(new ValidationPipe());
    await app.listen(3000);
  }
  bootstrap();
  ```

  app 모듈에서 ValidationPipe를 전역으로 사용할 것을 알려주도록 합시다.

2. 패키지 설치

  ```shell{outputLines: 2}
  npm install class-validator class-transformer // npm 설치 방식
  or
  yarn install class-validator class-transformer // yarn 설치 방식
  ```

3. Entity 적용

  3-1. Core Entity

  ```ts
  import { IsDate, IsNumber } from 'class-validator';
  import { CreateDateColumn, Entity, PrimaryGeneratedColumn, UpdateDateColumn } from 'typeorm';

  @Entity()
  export class Core {
    @PrimaryGeneratedColumn()
    // highlight-next-line
    @IsNumber()
    id: number;

    @CreateDateColumn()
    // highlight-next-line
    @IsDate()
    createdAt: Date;

    @UpdateDateColumn()
    // highlight-next-line
    @IsDate()
    updatedAt: Date;
  }
  ```

  3-2. User Entity

  ```ts
  import { classToPlain, Exclude } from 'class-transformer';
  import { IsEmail, IsString } from 'class-validator';
  import { Column, Entity } from 'typeorm';

  import { Core } from '@common/entities/core.entity';

  @Entity()
  export class User extends Core {
    @Column({ unique: true })
    // highlight-next-line
    @IsEmail()
    email: string;

    @Column()
    // highlight-next-line
    @IsString()
    firstName: string;

    @Column()
    // highlight-next-line
    @IsString()
    lastName: string;

    // highlight-next-line
    @Exclude({ toPlainOnly: true })
    @Column()
    // highlight-next-line
    @IsString()
    password: string;
  }
  ```

  class-validator와 class-transformer 라이브러리를 사용해 위와 같이 유효성 검사를 할 수 있도록 지정하였습니다. 
  클라이언트가 만약 email을 숫자나 이메일이 아닌 형태로 적어서 회원가입을 진행한다면 이것은 NestJS ValidationPipe를 통해 유효성 검사를 실패하여 회원가입을 진행할 수 없게 됩니다. 
  password 필드에는 @Exclude() 데코레이터를 사용했는데 이는 추후에 비밀번호를 노출시키지 않게 하기 위해 설정한 것으로 나중에 다시 설명하도록 하겠습니다.

## User DTO 만들기

`DTO`가 무엇인지, 그리고 왜 필요한지에 대해 간단하게 짚고 넘어갑시다. 
DTO는 Data Transfer Object의 약자로 데이터 전송 개체를 나타냅니다. 
이는 클라이언트 :point_right: 서버 또는 클라이언트 :point_left: 서버 방향으로 데이터를 네트워크를 통해 전송할 때 어떠한 방식으로 전송할 것인지를 
의미하며 대부분 객체의 형태를 띄우고 있습니다. 
DTO를 타입스크립트 클래스 형태로 정의하게 된다면 우리가 전송하는 데이터 또는 전송받는 데이터의 형태를 명확하게 지정할 수 있게 됩니다.

우리는 NestJS를 사용해 회원가입을 진행할 것이므로 가장 첫번째 DTO로 `CreateUserDto`를 만들어보도록 합시다.

1. core.dto.ts 생성

  Entity에서도 기본으로 가지게 되는 필수 필드들이 존재하듯이 DTO에서도 필수적으로 가지게 되는 필드들을 먼저 정의해보도록 합시다.

  :heavy_plus_sign: `src/common/dtos/core.dto.ts`
  ```ts
  import { IsBoolean, IsNotEmpty, IsOptional, IsString } from 'class-validator';

  export class CoreOutput {
    @IsBoolean()
    @IsNotEmpty()
    ok: boolean;

    @IsString()
    @IsOptional()
    error?: string;
  }
  ```

2. NestJS Mapped Types 패키지 설치

  ```shell{outputLines: 2}
  npm install @nestjs/mapped-types // npm 설치 방식
  or
  yarn install @nestjs/mapped-types // yarn 설치 방식
  ```

3. createUser.dto.ts 생성

  :heavy_plus_sign: `src/users/dtos/create-user.dto.ts`
  ```ts
  import { PickType } from '@nestjs/mapped-types';
  import { IsString } from 'class-validator';

  import { User } from '@users/entities/user.entity';
  import { CoreOutput } from '@common/dtos/core.dto';

  // highlight-next-line
  export class CreateUserInputDto extends PickType(User, ['email', 'firstName', 'lastName', 'password']) {
    @IsString()
    checkPassword: string;
  }

  // highlight-next-line
  export class CreateUserOutputDto extends CoreOutput {}
  ```

  회원가입을 진행할 때 클라이언트는 email, firstName, lastName, password를 입력하게 될 것입니다. 
  또한 checkPassword를 한번 더 입력하여 password가 일치하는지 확인까지 해보도록 합시다.
  그리고 서버는 클라이언트에게 ok와 error를 응답하게 될 것 입니다.

  위 코드의 하이라이트 부분은 설명을 나타내는 부분입니다. 
  PickType은 NestJS의 Mapped Types의 한가지 기능으로 CRUD와 같은 기능을 구축할 때 User Entity 타입에 대해 변형이 필요할 때 유용하게 사용할 수 있습니다. 
  OmitType, PartialType 등 더 많은 기능들이 있지만 CreateUserDto에서 필요한 기능은 PickType으로 
  필요한 부분만 선택할 수 있습니다. 
  또한 CreateUserOutputDto는 CoreOutput을 extends 하게 됨으로써 ok와 error 필드를 가지게 됩니다.

## User Controller & Service

회원가입에 필요한 DTO를 정의했으므로 사용해보도록 합시다.

1. users.service.ts 생성

  ```shell
  nest g service users
  ```

  `users/users.service.ts`
  ```ts{numberLines: true}
  import { Injectable } from '@nestjs/common';
  import { InjectRepository } from '@nestjs/typeorm';
  import { Repository } from 'typeorm';

  import { User } from '@users/entities/user.entity';
  import { CreateUserInputDto, CreateUserOutputDto } from '@users/dtos/create-user.dto';

  // highlight-next-line
  @Injectable()
  export class UsersService {
    // highlight-next-line
    constructor(@InjectRepository(User) private readonly userRepository: Repository<User>) {}

    async createUser(createUserInputDto: CreateUserInputDto): Promise<CreateUserOutputDto> {}
  }
  ```

  UsersService에서 User Entity를 사용할 것이므로 주입하여 줍시다. 
  또한 @Injectable 데코레이터를 사용해 주입될 프로바이더임을 명시해줘야 합니다. 
  그 이유는 추후에 usersService가 User Controller 및 다른 곳에서 사용될 수 있기 때문입니다. 
  저장하고 서버 상태를 확인해보시면 에러가 발생했을 확률이 있습니다. 
  조금 뒤에 고칠 예정이니 우선은 계속해서 진행해 보도록 하겠습니다.

2. users.controller.ts 생성

  ```shell
  nest g co users
  ```

  `users/users.controller.ts`
  ```ts
  import { Body, Controller, Post } from '@nestjs/common';

  import { CreateUserInputDto } from '@users/dtos/create-user.dto';
  import { UsersService } from '@users/users.service';

  @Controller('users')
  export class UsersController {
    // highlight-next-line
    constructor(private readonly usersService: UsersService) {}

    @Post()
    async createUser(@Body() createUserInputDto: CreateUserInputDto) {
      return this.usersService.createUser(createUserInputDto);
    }
  }
  ```

  Express 프레임워크를 사용해봤다면 컨트롤러가 어떠한 역할을 하는지 알기 쉬울 것 입니다. 
  `/users` 경로에서 회원가입을 진행하는데 그때 필요한 로직이 usersService의 createUser 메서드에 담겨 있습니다. 

3. users.module.ts

  `users.module.ts`
  ```ts{numberLines: true}
  import { TypeOrmModule } from '@nestjs/typeorm';

  import { User } from '@users/entities/user.entity';
  import { UsersController } from '@users/users.controller';
  import { UsersService } from '@users/users.service';

  @Module({
    // highlight-start
    imports: [TypeOrmModule.forFeature([User])],
    controllers: [UsersController],
    providers: [UsersService],
    // highlight-end
  })
  export class UsersModule {}
  ```

  **아주 중요한 부분입니다.** 
  nest cli를 통해 user.service.ts와 users.controller.ts를 생성했다면 자동으로 import 되었겠지만 
  매뉴얼로 생성했다면 반드시 추가해줘야 합니다.

  8번 라인은 user.service.ts에서 User Entity를 사용하므로 import하여 외부로부터 주입받은 형태입니다.

  9번 라인은 사용하게 될 컨트롤러를 등록하며 10번라인은 users.controller.ts에서 usersService를 사용하므로 providers 배열에 
  제공해줘야 사용이 가능합니다.

  저장을 하고 서버에 에러가 발생하지 않았는지 확인하시길 바랍니다. 
  만약 에러가 아직 존재한다면 Inject하는 부분에서 실수를 한 확률이 크다는 점을 주의해주세요.

