---
title: NestJS 로그인 구현하기(Passport Local & Jwt)
date: 2021-07-26
slug: /blog/project/mafia/login
categories: ['all', 'project']
tags: ['NestJS', 'TypeScript', 'Passport-Local', 'Passport-JWT', 'TypeORM', 'MySQL']
---

Passport는 NodeJS에서 가장 많이 사용되는 인증 라이브러리로 NestJS 역시 추천하는 방식입니다. 
또한 NestJS는 NodeJS 위에서 작동하므로 Passport와 통합하는 방법도 이미 제공되고 있습니다. 
따라서 이번 글에서는 NestJS 공식 문서를 참고하여 로그인을 구현할 것 입니다.

Passport에는 인증 메커니즘을 구현하는 여러가지 전략을 구성하고 있는데 우리가 맨 처음으로 구현해볼 인증 메커니즘은 
`passport-local` 전략으로 사용자 이름/비밀번호를 이용해 가장 기본적인 인증부터 시작해볼 것 입니다. 
그 후, 서버가 인증을 증명하기 위한 후속 요청에서 인증 헤더의 전달자 토큰으로 전송할 수 있는 JWT를 발행하고 JWT를 가지고 
있는 사용자들만 액세스 할 수 있는 경로를 생성해 외부 사용자로부터 액세스하는 것을 보호해보도록 하겠습니다.

시작하겠습니다. :wink:

## Find User

가장 먼저 로그인을 진행할 때 데이터베이스에 존재하는 유저가 있는지 확인하는 로직을 작성할 것 입니다.

1. Get User Dto 생성

  `src/users/get-user.dto.ts`
  ```ts
  import { CoreOutput } from '@common/dtos/core.dto';
  import { PickType } from '@nestjs/mapped-types';

  import { User } from '@users/entities/user.entity';
  import { IsOptional } from 'class-validator';

  export class GetUserInputDto extends PickType(User, ['email']) {}

  export class GetUserOutputDto extends CoreOutput {
    @IsOptional()
    user?: User;
  }
  ```

  클라이언트로부터 eamil을 입력받았을 때 user가 존재한다면 반환할 것이고 그렇지 않다면 error를 줄 것 입니다.

2. Find One User Service

  `src/users.service.ts`
  ```ts
  ...
  import { GetUserInputDto, GetUserOutputDto } from '@users/dtos/get-user.dto';

  @Injectable()
  export class UsersService {
    constructor(@InjectRepository(User) private readonly userRepository: Repository<User>) {}

    ...

    /* Find One User */
    // highlight-start
    async findOneUser(getUserInputDto: GetUserInputDto): Promise<GetUserOutputDto> {
      try {
        const { email } = getUserInputDto;
        const user = await this.userRepository.findOne({ email });
        if (!user) return { ok: false, error: '해당 유저를 찾을 수 없습니다.' };
        return { ok: true, user };
      } catch (error) {
        return { ok: false, error: '유저 탐색을 실패했습니다.' };
      }
    }
    // highlight-end
  }
  ```

  데이터베이스로부터 유저가 존재하지 않다면 :point_right: `ts$return { ok: false, error: '해당 유저를 찾을 수 없습니다.' }` 
  유저가 존재한다면 :point_right: `ts$return { ok: true, user }`를 반환합니다.

## Validate User

유저를 찾은 후 유저를 검증해보는 절차를 구현합니다.

1. auth.module.ts 생성

  ```shell
  nest g mo auth
  ```

2. validateAuthDto 생성

  :heavy_plus_sign: `src/auth/dtos/validate-auth.dto.ts`
  ```ts
  import { CoreOutput } from '@common/dtos/core.dto';
  import { PickType } from '@nestjs/mapped-types';
  import { User } from '@users/entities/user.entity';
  import { IsOptional } from 'class-validator';

  export class ValidateAuthInputDto extends PickType(User, ['email', 'password']) {}

  export class ValidateAuthOutputDto extends CoreOutput {
    @IsOptional()
    user?: User;
  }
  ```

3. auth.service.ts 생성

  ```shell
  nest g service auth
  ```

4. Validate User Service 로직 구현

  `src/users/entities/user.entity.ts`
  ```ts
  ...
  import * as bcrypt from 'bcrypt';

  export class User extends Core {
    ...

    @Exclude({ toPlainOnly: true })
    @Column()
    @IsString()
    password: string;

    @BeforeInsert()
    async hashPassword() {
      this.password = await bcrypt.hash(this.password, 10);
    }

    // highlight-start
    async validatePassword(password: string): Promise<boolean> {
      return bcrypt.compare(password, this.password);
    }
    // highlight-end
  }
  ```

  `src/auth/auth.service.ts`
  ```ts
  import { Injectable } from '@nestjs/common';

  // highlight-next-line
  import { ValidateAuthInputDto, ValidateAuthOutputDto } from '@auth/dtos/validate-auth.dto';
  import { UsersService } from '@users/users.service';

  @Injectable()
  export class AuthService {
    constructor(private readonly usersService: UsersService) {}

    /* Validate User */
    // highlight-start
    async validateUser(validateAuthInputDto: ValidateAuthInputDto): Promise<ValidateAuthOutputDto> {
      try {
        const { email, password } = validateAuthInputDto;
        const { user } = await this.usersService.findOneUser({ email });
        if (!user) return { ok: false, error: '이메일 계정이 존재하지 않습니다.' };
        if (user && (await user.validatePassword(password)) === false) {
          return { ok: false, error: '패스워드가 일치하지 않습니다.' };
        }
        return { ok: true, user };
      } catch (error) {
        return { ok: false, error: '로그인 인증에 실패하였습니다.' };
      }
    }
  }
    // highlight-end
  ```

  usersService의 findOneUser 메서드로부터 user가 있는지 검증, 
  user가 존재한다면 패스워드 입력이 일치했는지 검증한다. 
  검증 도중 에러가 발생하면 `ts$return { ok: false, error: '로그인 인증에 실패하였습니다.' }`를 리턴합니다.

## Passport Local Strategy 구현

Passport에서 제공하는 Local Strategy를 구현하여 유효한 사용자를 반환할 것 입니다.

1. 패키지 설치

  ```shell{outputLines: 3}
  npm install @nestjs/passport passport passport-local // npm 설치 방식
  npm install -D @types/passport-local // npm 설치 방식
  or
  yarn add @nestjs/passport passport passport-local // yarn 설치 방식
  yarn add -D @types/passport-local // yarn 설치 방식
  ```

2. Local Strategy 생성

  `src/users/entities/user.entity.ts`
  ```ts
  ...
  import * as bcrypt from 'bcrypt';
  // highlight-next-line
  import { classToPlain, Exclude } from 'class-transformer';

  export class User extends Core {
    ...

    @Exclude({ toPlainOnly: true })
    @Column()
    @IsString()
    password: string;

    @BeforeInsert()
    async hashPassword() {
      this.password = await bcrypt.hash(this.password, 10);
    }

    async validatePassword(password: string): Promise<boolean> {
      return bcrypt.compare(password, this.password);
    }

    // highlight-start
    toJSON() {
      return classToPlain(this);
    }
    // highlight-end
  }
  ```

  :heavy_plus_sign: `src/auth/strategies/local.strategy.ts`
  ```ts{numberLines: true}
  import { AuthService } from '@auth/auth.service';
  import { ValidateAuthOutputDto } from '@auth/dtos/validate-auth.dto';
  import { Injectable } from '@nestjs/common';
  import { PassportStrategy } from '@nestjs/passport';
  import { User } from '@users/entities/user.entity';
  import { plainToClass } from 'class-transformer';
  import { Strategy } from 'passport-local';

  @Injectable()
  // highlight-start
  export class LocalStrategy extends PassportStrategy(Strategy) {
    constructor(private readonly authService: AuthService) {
      super({ usernameField: 'email' });
    }
    // highlight-end

    async validate(email: string, password: string): Promise<ValidateAuthOutputDto> {
      try {
        const result = await this.authService.validateUser({ email, password });
        const { ok, error } = result;
        let { data: user } = result;
        if (ok === false) return { ok: false, error };
        if (!user) {
          return { ok: false, error: '로그인 인증에 실패하였습니다.' };
        }
        // highlight-start
        const plainUser = user.toJSON();
        user = plainToClass(User, plainUser);
        // highlight-end
        return { ok: true, data: user };
      } catch (error) {
        console.log(error);
        return { ok: false, error: '로그인 인증에 실패하였습니다.' };
      }
    }
  }
  ```

  Passport LocalStrategy를 구현하는 부분으로 가장 중요한 역할을 합니다. 
  10 ~ 13라인을 자세히 보면 설치해온 라이브러리로부터 클래스를 연장합니다. 
  PassportStrategy(Strategy)에서 `Strategy`는 반드시 passport-local로부터 import 해와야 합니다. 
  에디터에서 Strategy를 클릭해보면 어떠한 타입으로 정의했는지 살펴볼 수 있습니다. 
  여기서 constructor의 options를 확인해보면 usernameField가 있는 것을 알 수 있는데 
  이는 무엇을 username으로 지정할지 선택하는 것 입니다. 
  기본적으로 username으로 지정되어 있으나 저는 email 필드를 사용해 로그인을 진행할 것이므로 수정하도록 하겠습니다.

  그리고 LocalStrategy는 `validate` 메서드를 가지는데 주의할 점은 반드시 `validate` 이름을 가진 메서드로 구현해야 한다는 점입니다. 
  이는 우리가 선택하는 것이 아닌 `@nestjs/passport` 로부터 주어진 룰입니다. 
  이 룰을 따르지 않고 메서드명을 마음대로 한다면 로그인을 할 수 없을 것 입니다.

  마지막으로 valite 메서드에서 24 ~ 25번 라인을 살펴보면 user에 이상한 작업을 하는 것을 알 수 있습니다. 
  Passport는 전략을 통과한 사용자에게 req.user 속성으로 user 객체를 반환하게 되는데 그대로 반환하게 되면 
  req.user에 password를 가진 user를 반환하게 됩니다. 

  ```
  User {
    id: 1,
    email: "admin@gmail.com",
    firstName: "이",
    lastName: "민찬",
    password: "5hhersag$!@4gr..."
  }
  ```

  이와 같이 user를 클라이언트 측에 제공하는 것은 보안면으로 매우 좋지 않습니다. 
  저는 password를 클라이언트에 노출하고 싶지 않기 때문에 24 ~ 25번 라인과 같은 후속조치를 한 것 입니다. 
  방법은 두가지를 생각해볼 수 있는데 첫번째는 user객체에서 password를 뺀 나머지 속성만 반환하는 것. 
  또는 저처럼 `class-transformer` 라이브러리를 활용해보는 방법이 있습니다.

  ```ts
  @Exclude({ toPlainOnly: true })
  @Column()
  @IsString()
  password: string;
  ```

  위 코드는 아까 위에서 user.entity.ts에서 password 필드에 적용한 @Exclude 데코레이터 입니다. 
  이 데코레이터의 속성으로 `ts${ toPlainOnly: true }`를 적용했는데 이것이 무슨 뜻인가 하면 
  plain 상태일 때는 password를 제공하지 않음을 나타냅니다. 
  따라서 LocalStrategy 전략으로 req.user을 보내기전에 `classToPlain` 메서드를 통해 User 클래스를 plain으로 변경하는 것 입니다.
  그렇다고 palin 타입으로 반환하면 타입 오류가 발생하므로 다시 `plainToClass` 메서드로 변경하여 리턴하도록 합시다.

## Local Login

몇가지만 업데이트 한 후 로그인 테스트를 진행해 봅시다.

1. auth.controller.ts 생성

  ```shell
  nest g co auth
  ```

2. auth.module.ts 수정

  `src/auth/auth.module.ts`
  ```ts
  import { Module } from '@nestjs/common';
    // highlight-next-line
  import { PassportModule } from '@nestjs/passport';

  import { AuthController } from '@auth/auth.controller';
  import { AuthService } from '@auth/auth.service';
    // highlight-next-line
  import { LocalStrategy } from '@auth/strategies/local.strategy';
  import { UsersModule } from '@users/users.module';

  @Module({
    // highlight-start
    imports: [UsersModule, PassportModule],
    providers: [AuthService, LocalStrategy],
    controllers: [AuthController],
    // highlight-end
  })
  export class AuthModule {}
  ```

  PassportModule을 import하고 LocalStrategy를 providers에 제공해줘야 저장했을 때 에러없이 서버가 동작할 것 입니다.

3. auth.controller.ts 수정

  `src/auth/auth.controller.ts`
  ```ts
  import { Controller, Post, Request, UseGuards } from '@nestjs/common';
  import { AuthGuard } from '@nestjs/passport';

  // highlight-start
  @Controller('auth')
  export class AuthController {
    @UseGuards(AuthGuard('local'))
    @Post('login')
    async login(@Request() req) {
      return req.user;
    }
  }
  // highlight-end
  ```

  위 코드는 로그인이 진행되면 req.user를 리턴할 것 입니다. 
  또한 @nestjs/passport에서 AuthGuard를 가져와 `@UseGuards(AuthGuard('local'))`와 같이 local 전략을 사용할 것임을 명시합니다. 
  현재는 Passport로부터 사용하는 전략이 하나밖에 없어 사용하는 의미가 잘 와닿지 않을 수 있으나 
  곧 사용하게 될 JWT 전략이나 소셜 로그인을 통한 전략을 구분하기 위해서는 사용하는 것이 좋습니다.

이제 Insomnia에서 테스트를 해보도록 하겠습니다. 
이전 글에서 회원가입한 유저로 로그인을 진행해 볼게요.

- Passport Local Strategy Login

  ![Passport Local Strategy Login](./gatsby-project-mafia-login-01.PNG 'Passport Local Strategy Login')

- Passport Local Strategy Login Result

  ```
  {
    id: 1,
    email: "admin@gmail.com",
    firstName: "이",
    lastName: "민찬",
  }
  ```

  위와 같이 유저 정보를 확인할 수 있다면 성공적으로 Passport LocalStrategy를 통해 로그인을 한 것 입니다. :heart_eyes:

여기까지 진행한 Passport Local Strategy 흐름이 이해되셨나요? 
이해한 것을 정리하기 위해 다시 한번 정확히 짚고 넘어가도록 합시다.

- 클라이언트 측에서 이메일/패스워드로 로그인
- `users.service.ts`의 `findOneUser`메서드로부터 user를 찾는다. 
- user가 존재한다면 `auth.service.ts`의 `validateUser` 메서드로부터 user 검증을 진행 
- user 검증이 완료되면 `LocalStrategy` 전략의 `validate` 메서드를 통해 user를 plain형태로 필터링을 거쳐 
다시 클래스 형태로 변환하여 `req.user`로 넘겨주게 된다.

## JWT Functionality

우리는 이제 Passport LocalStrategy를 사용해 유저 정보를 `req.user`로부터 가져올 수 있다는 것을 알 수 있습니다. 
하지만 아직 완전한 로그인을 구현하기까지 큰 문제점이 남아있습니다. 
그것은 바로 로그인을 통해 유저의 정보를 가져올 수 있지만 유저의 정보를 기억하지는 못한다는 것 입니다. 
예를 들어 로그인 후에 로그인 페이지 외에 다른 페이지로 이동한다면 `req.user`의 유저 객체의 정보는 모두 휘발유처럼 날아갈 것 입니다. 
이것은 HTTP 프로토콜이 Connenctionless(비연결상태)하며 Stateless(비상태유지)하기 때문입니다. 
즉, 유저 정보를 기억할 수 있는 지속성이 존재하지 않는다는 것 입니다. 
이를 해결하기 위한 방법으로는 대표적으로 쿠키와 세션을 이용하는 방법이 있으며 
쿠키와 세션 방식은 클라이언트가 로그인을 완료했을 때 서버는 클라이언트에게 세션ID값을 쿠키로 제공하며 
그 이후에 발생하는 클라이언트의 모든 요청은 쿠키와 함께 서버에 전송함으로써 유효한 세션ID인지 저장소로부터 확인하게 되면서 
해당 사용자가 누구인지 식별할 수 있게 되는 것입니다.

NestJS는 이러한 후속 호출에 대하여 식별할 수 있는 방안으로 `JWT(JSON Web Token)`을 소개하고 있습니다. 
Jwt는 쿠키와 세션 방식과 다르게 데이터베이스에 접근하여 사용자 정보를 가져오는 것이 아니고 
사용자 인증에 필요한 정보를 JSON 객체에 담아 암호화/서명 하는 방법을 말합니다. 
JWT의 자세한 설명을 하기보다 실제 어떻게 JWT가 인증의 후속조치를 돕는지 알아보는 것이 
더 빠른 이해를 도와줄 것 입니다.

## JWT Login

클라이언트로부터 로그인을 진행하게 될 시, JWT 인증 방식을 사용하여 유효한 토큰을 발행할 것 입니다.

1. Login Auth Dto 생성

  :heavy_plus_sign: `src/auth/dtos/login-auth.dto.ts`
  ```ts
  import { IsOptional, IsString } from 'class-validator';

  import { CoreOutput } from '@common/dtos/core.dto';
  import { User } from '@users/entities/user.entity';

  export class LoginAuthInputDto extends CoreOutput {
    @IsOptional()
    @IsString()
    data?: User;
  }

  export class LoginAuthOutputDto extends CoreOutput {
    @IsOptional()
    @IsString()
    access_token?: string;
  }
  ```

  req.user 객체를 파라미터로 전달할 것이며 ok, error, data로 이루어져 있습니다. 
  그리고 JWT 인증을 성공적으로 마치면 토큰을 발급하여 ok, error, access_token의 결과를 출력할 것 입니다.

2. auth.service.ts :point_right: login 메서드 추가

  `src/auth/auth.service.ts`
  ```ts
  ...
  // highlight-next-line
  import { JwtService } from '@nestjs/jwt';
  import { LoginAuthInputDto, LoginAuthOutputDto } from '@auth/dtos/login-auth.dto';

  @Injectable()
  export class AuthService {
    // highlight-next-line
    constructor(private readonly usersService: UsersService, private readonly jwtService: JwtService) {}

    /* Login Service */
    // highlight-start
    async login(loginAuthInputDto: LoginAuthInputDto): Promise<LoginAuthOutputDto> {
      const { ok, error, data } = loginAuthInputDto;
      if (ok === false) return { ok: false, error };
      if (data == null) return { ok: false, error: '토큰을 발급 받을 수 없습니다.' };
      const { id, email, firstName, lastName } = data;
      const payload = { id, email, firstName, lastName };
      return {
        ok: true,
        access_token: this.jwtService.sign(payload),
      };
    }
    // highlight-end
  }
  ```

  로그인 진행 중 에러가 발생하면 그대로 에러를 결과값으로 보여주고 `req.user.data`값에 user 정보가 아무것도 들어있지 않다면 
  마찬가지로 '토큰을 발급 받을 수 없음'을 클라이언트에게 알려줄 것 입니다. 
  에러가 없다면 유저로부터 payload를 구성합니다. 
  JWT에서 payload는 유저의 정보를 담을 객체를 뜻하며 후에 토큰이 유효한 사용자에게 유저 정보를 제공할 객체가 됩니다. 
  payload에 유저에 관한 정보를 담았다면 @nest/jwt 패키지로부터 jwtService 클래스의 sign메서드의 인자로 제공해 
  `access_token`을 발급하여 결과값으로 전달하도록 합니다.

3. auth.controller.ts 수정

  `src/auth/auth.controller.ts`
  ```ts
  ...
  import { LoginAuthOutputDto } from '@auth/dtos/login-auth.dto';

  // highlight-next-line
  type RequestWithUser = Request & { user: ValidateAuthOutputDto };

  @Controller('auth')
  export class AuthController {
    constructor(private readonly authService: AuthService) {}

    /* Post Login Controller */
    @UseGuards(LocalAuthGuard)
    // highlight-start
    @Post('login')
    async login(@Req() req: RequestWithUser): Promise<LoginAuthOutputDto> {
      return this.authService.login(req.user);
    }
    // highlight-end
  }
  ```

  `auth/login` 경로에서 로그인이 이루어지고 실패하면 에러를 성공하면 토큰을 발급받게 됩니다.