---
title: NestJS 로그인 구현하기(Passport Local & Jwt)
date: 2021-07-26
slug: /blog/project/mafia/login
categories: ['all', 'project']
tags: ['NestJS', 'TypeScript', 'Passport-Local', 'Passport-JWT', 'TypeORM', 'MySQL']
---

Passport는 NodeJS에서 가장 많이 사용되는 인증 라이브러리로 NestJS 역시 추천하는 방식입니다. 
또한 NestJS는 NodeJS 위에서 작동하므로 Passport와 통합하는 방법도 이미 제공되고 있습니다. 
따라서 이번 글에서는 NestJS 공식 문서를 참고하여 로그인을 구현할 것 입니다.

Passport에는 인증 메커니즘을 구현하는 여러가지 전략을 구성하고 있는데 우리가 맨 처음으로 구현해볼 인증 메커니즘은 
`passport-local` 전략으로 사용자 이름/비밀번호를 이용해 가장 기본적인 인증부터 시작해볼 것 입니다. 
그 후, 서버가 인증을 증명하기 위한 후속 요청에서 인증 헤더의 전달자 토큰으로 전송할 수 있는 JWT를 발행하여 JWT를 가지고 
있는 사용자에게만 액세스 할 수 있는 보호 경로를 생성해 보도록 합시다. 

시작하겠습니다. :wink:

## Find User

가장 먼저 로그인을 진행할 때 데이터베이스에 존재하는 유저가 있는지 확인하는 로직을 작성할 것 입니다.

1. Get User Dto 생성

  `src/users/get-user.dto.ts`
  ```ts
  import { CoreOutput } from '@common/dtos/core.dto';
  import { PickType } from '@nestjs/mapped-types';

  import { User } from '@users/entities/user.entity';
  import { IsOptional } from 'class-validator';

  export class GetUserInputDto extends PickType(User, ['email']) {}

  export class GetUserOutputDto extends CoreOutput {
    @IsOptional()
    user?: User;
  }
  ```

  클라이언트로부터 eamil을 입력받았을 때 user가 존재한다면 반환할 것이고 그렇지 않다면 error를 줄 것 입니다.

2. Find One User Service

  `src/users.service.ts`
  ```ts
  ...
  import { GetUserInputDto, GetUserOutputDto } from '@users/dtos/get-user.dto';

  @Injectable()
  export class UsersService {
    constructor(@InjectRepository(User) private readonly userRepository: Repository<User>) {}

    ...

    /* Find One User */
    // highlight-start
    async findOneUser(getUserInputDto: GetUserInputDto): Promise<GetUserOutputDto> {
      try {
        const { email } = getUserInputDto;
        const user = await this.userRepository.findOne({ email });
        if (!user) return { ok: false, error: '해당 유저를 찾을 수 없습니다.' };
        return { ok: true, user };
      } catch (error) {
        return { ok: false, error: '유저 탐색을 실패했습니다.' };
      }
    }
    // highlight-end
  }
  ```

  데이터베이스로부터 유저가 존재하지 않다면 :point_right: `ts$return { ok: false, error: '해당 유저를 찾을 수 없습니다.' }` 
  유저가 존재한다면 :point_right: `ts$return { ok: true, user }`를 반환합니다.

## Validate User

유저를 찾은 후 유저를 검증해보는 절차를 구현합니다.

1. auth.module.ts 생성

  ```shell
  nest g mo auth
  ```

2. validateAuthDto 생성

  :heavy_plus_sign: `src/auth/dtos/validate-auth.dto.ts`
  ```ts
  import { CoreOutput } from '@common/dtos/core.dto';
  import { PickType } from '@nestjs/mapped-types';
  import { User } from '@users/entities/user.entity';
  import { IsOptional } from 'class-validator';

  export class ValidateAuthInputDto extends PickType(User, ['email', 'password']) {}

  export class ValidateAuthOutputDto extends CoreOutput {
    @IsOptional()
    user?: User;
  }
  ```

3. auth.service.ts 생성

  ```shell
  nest g service auth
  ```

4. Validate User Service 로직 구현

  `src/users/entities/user.entity.ts`
  ```ts
  ...
  import * as bcrypt from 'bcrypt';

  export class User extends Core {
    ...

    @Exclude({ toPlainOnly: true })
    @Column()
    @IsString()
    password: string;

    @BeforeInsert()
    async hashPassword() {
      this.password = await bcrypt.hash(this.password, 10);
    }

    // highlight-start
    async validatePassword(password: string): Promise<boolean> {
      return bcrypt.compare(password, this.password);
    }
    // highlight-end
  }
  ```

  `src/auth/auth.service.ts`
  ```ts
  import { Injectable } from '@nestjs/common';

  // highlight-next-line
  import { ValidateAuthInputDto, ValidateAuthOutputDto } from '@auth/dtos/validate-auth.dto';
  import { UsersService } from '@users/users.service';

  @Injectable()
  export class AuthService {
    constructor(private readonly usersService: UsersService) {}

    /* Validate User */
    // highlight-start
    async validateUser(validateAuthInputDto: ValidateAuthInputDto): Promise<ValidateAuthOutputDto> {
      try {
        const { email, password } = validateAuthInputDto;
        const { user } = await this.usersService.findOneUser({ email });
        if (!user) return { ok: false, error: '이메일 계정이 존재하지 않습니다.' };
        if (user && (await user.validatePassword(password)) === false) {
          return { ok: false, error: '패스워드가 일치하지 않습니다.' };
        }
        return { ok: true, user };
      } catch (error) {
        return { ok: false, error: '로그인 인증에 실패하였습니다.' };
      }
    }
  }
    // highlight-end
  ```

  usersService의 findOneUser 메서드로부터 user가 있는지 검증, 
  user가 존재한다면 패스워드 입력이 일치했는지 검증한다. 
  검증 도중 에러가 발생하면 `ts$return { ok: false, error: '로그인 인증에 실패하였습니다.' }`를 리턴합니다.

## Passport Local Strategy 구현

Passport에서 제공하는 Local Strategy를 구현하여 유효한 사용자를 반환할 것 입니다.

1. 패키지 설치

  ```shell{outputLines: 3}
  npm install @nestjs/passport passport passport-local // npm 설치 방식
  npm install -D @types/passport-local // npm 설치 방식
  or
  yarn add @nestjs/passport passport passport-local // yarn 설치 방식
  yarn add -D @types/passport-local // yarn 설치 방식
  ```

2. Local Strategy 생성

  `src/users/entities/user.entity.ts`
  ```ts
  ...
  import * as bcrypt from 'bcrypt';
  // highlight-next-line
  import { classToPlain, Exclude } from 'class-transformer';

  export class User extends Core {
    ...

    @Exclude({ toPlainOnly: true })
    @Column()
    @IsString()
    password: string;

    @BeforeInsert()
    async hashPassword() {
      this.password = await bcrypt.hash(this.password, 10);
    }

    async validatePassword(password: string): Promise<boolean> {
      return bcrypt.compare(password, this.password);
    }

    // highlight-start
    toJSON() {
      return classToPlain(this);
    }
    // highlight-end
  }
  ```

  :heavy_plus_sign: `src/auth/strategies/local.strategy.ts`
  ```ts{numberLines: true}
  import { AuthService } from '@auth/auth.service';
  import { ValidateAuthOutputDto } from '@auth/dtos/validate-auth.dto';
  import { Injectable } from '@nestjs/common';
  import { PassportStrategy } from '@nestjs/passport';
  import { User } from '@users/entities/user.entity';
  import { plainToClass } from 'class-transformer';
  import { Strategy } from 'passport-local';

  @Injectable()
  // highlight-start
  export class LocalStrategy extends PassportStrategy(Strategy) {
    constructor(private readonly authService: AuthService) {
      super({ usernameField: 'email' });
    }
    // highlight-end

    async validate(email: string, password: string): Promise<ValidateAuthOutputDto> {
      try {
        const result = await this.authService.validateUser({ email, password });
        const { ok, error } = result;
        let { data: user } = result;
        if (ok === false) return { ok: false, error };
        if (!user) {
          return { ok: false, error: '로그인 인증에 실패하였습니다.' };
        }
        // highlight-start
        const plainUser = user.toJSON();
        user = plainToClass(User, plainUser);
        // highlight-end
        return { ok: true, data: user };
      } catch (error) {
        console.log(error);
        return { ok: false, error: '로그인 인증에 실패하였습니다.' };
      }
    }
  }
  ```

  Passport LocalStrategy를 구현하는 부분으로 가장 중요한 역할을 합니다. 
  10 ~ 13라인을 자세히 보면 설치해온 라이브러리로부터 클래스를 연장합니다. 
  PassportStrategy(Strategy)에서 `Strategy`는 반드시 passport-local로부터 import 해와야 합니다. 
  에디터에서 Strategy를 클릭해보면 어떠한 타입으로 정의했는지 살펴볼 수 있습니다. 
  여기서 constructor의 options를 확인해보면 usernameField가 있는 것을 알 수 있는데 
  이는 무엇을 username으로 지정할지 선택하는 것 입니다. 
  기본적으로 username으로 지정되어 있으나 저는 email 필드를 사용해 로그인을 진행할 것이므로 수정하도록 하겠습니다.

  그리고 LocalStrategy는 `validate` 메서드를 가지는데 주의할 점은 반드시 `validate` 이름을 가진 메서드로 구현해야 한다는 점입니다. 
  이는 우리가 선택하는 것이 아닌 `@nestjs/passport` 로부터 주어진 룰입니다. 
  이 룰을 따르지 않고 메서드명을 마음대로 한다면 로그인을 할 수 없을 것 입니다.

  마지막으로 valite 메서드에서 24 ~ 25번 라인을 살펴보면 user에 이상한 작업을 하는 것을 알 수 있습니다. 
  Passport는 전략을 통과한 사용자에게 req.user 속성으로 user 객체를 반환하게 되는데 그대로 반환하게 되면 
  req.user에 password를 가진 user를 반환하게 됩니다. 

  ```
  User {
    id: 1,
    email: "admin@gmail.com",
    firstName: "이",
    lastName: "민찬",
    password: "5hhersag$!@4gr..."
  }
  ```

  이와 같이 user를 클라이언트 측에 제공하는 것은 보안면으로 매우 좋지 않습니다. 
  저는 password를 클라이언트에 노출하고 싶지 않기 때문에 24 ~ 25번 라인과 같은 후속조치를 한 것 입니다. 
  방법은 두가지를 생각해볼 수 있는데 첫번째는 user객체에서 password를 뺀 나머지 속성만 반환하는 것. 
  또는 저처럼 `class-transformer` 라이브러리를 활용해보는 방법이 있습니다.

  ```ts
  @Exclude({ toPlainOnly: true })
  @Column()
  @IsString()
  password: string;
  ```

  위 코드는 아까 위에서 user.entity.ts에서 password 필드에 적용한 @Exclude 데코레이터 입니다. 
  이 데코레이터의 속성으로 `ts${ toPlainOnly: true }`를 적용했는데 이것이 무슨 뜻인가 하면 
  plain 상태일 때는 password를 제공하지 않음을 나타냅니다. 
  따라서 LocalStrategy 전략으로 req.user을 보내기전에 `classToPlain` 메서드를 통해 User 클래스를 plain으로 변경하는 것 입니다.
  그렇다고 palin 타입으로 반환하면 타입 오류가 발생하므로 다시 `plainToClass` 메서드로 변경하여 리턴하도록 합시다.

여기까지 흐름을 정확히 정리하고 넘어가도록 하겠습니다. 

- 클라이언트 측에서 이메일/패스워드로 로그인 
- `users.service.ts`의 `findOneUser`메서드로부터 user를 찾는다. 
- user가 존재한다면 `auth.service.ts`의 `validateUser` 메서드로부터 user 검증을 진행 
- user 검증이 완료되면 `LocalStrategy` 전략의 `validate` 메서드를 통해 user를 plain형태로 필터링을 거쳐 
다시 클래스 형태로 변환하여 req.user로 넘겨주게 된다.