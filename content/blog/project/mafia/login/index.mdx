---
title: NestJS 로그인 구현하기(Passport Local & Jwt)
date: 2021-07-26
slug: /blog/project/mafia/login
categories: ['all', 'project']
tags: ['NestJS', 'TypeScript', 'Passport-Local', 'Passport-JWT', 'TypeORM', 'MySQL']
---

Passport는 NodeJS에서 가장 많이 사용되는 인증 라이브러리로 NestJS 역시 추천하는 방식입니다. 
또한 NestJS는 NodeJS 위에서 작동하므로 Passport와 통합하는 방법도 이미 제공되고 있습니다. 
따라서 이번 글에서는 NestJS 공식 문서를 참고하여 로그인을 구현할 것 입니다.

Passport에는 인증 메커니즘을 구현하는 여러가지 전략을 구성하고 있는데 우리가 맨 처음으로 구현해볼 인증 메커니즘은 
`passport-local` 전략으로 사용자 이름/비밀번호를 이용해 가장 기본적인 인증부터 시작해볼 것 입니다. 
그 후, 서버가 인증을 증명하기 위한 후속 요청에서 인증 헤더의 전달자 토큰으로 전송할 수 있는 JWT를 발행하여 JWT를 가지고 
있는 사용자에게만 액세스 할 수 있는 보호 경로를 생성해 보도록 합시다. 

시작하겠습니다. :wink:

## Find User

가장 먼저 로그인을 진행할 때 데이터베이스에 존재하는 유저가 있는지 확인하는 로직을 작성할 것 입니다.

1. Get User Dto 생성

  `src/users/get-user.dto.ts`
  ```ts
  import { CoreOutput } from '@common/dtos/core.dto';
  import { PickType } from '@nestjs/mapped-types';

  import { User } from '@users/entities/user.entity';
  import { IsOptional } from 'class-validator';

  export class GetUserInputDto extends PickType(User, ['email']) {}

  export class GetUserOutputDto extends CoreOutput {
    @IsOptional()
    user?: User;
  }
  ```

  클라이언트로부터 eamil을 입력받았을 때 user가 존재한다면 반환할 것이고 그렇지 않다면 error를 줄 것 입니다.

2. Find One User Service

  `src/users.service.ts`
  ```ts
  ...
  import { GetUserInputDto, GetUserOutputDto } from '@users/dtos/get-user.dto';

  @Injectable()
  export class UsersService {
    constructor(@InjectRepository(User) private readonly userRepository: Repository<User>) {}

    ...

    /* Find One User */
    // highlight-start
    async findOneUser(getUserInputDto: GetUserInputDto): Promise<GetUserOutputDto> {
      try {
        const { email } = getUserInputDto;
        const user = await this.userRepository.findOne({ email });
        if (!user) return { ok: false, error: '해당 유저를 찾을 수 없습니다.' };
        return { ok: true, user };
      } catch (error) {
        return { ok: false, error: '유저 탐색을 실패했습니다.' };
      }
    }
    // highlight-end
  }
  ```

  데이터베이스로부터 유저가 존재하지 않다면 :point_right: `ts$return { ok: false, error: '해당 유저를 찾을 수 없습니다.' }` 
  유저가 존재한다면 :point_right: `ts$return { ok: true, user }`를 반환합니다.

## Validate User

유저를 찾은 후 유저를 검증해보는 절차를 구현합니다.

1. auth.module.ts 생성

  ```shell
  nest g mo auth
  ```

2. validateAuthDto 생성

  :heavy_plus_sign: `src/auth/dtos/validate-auth.dto.ts`
  ```ts
  import { CoreOutput } from '@common/dtos/core.dto';
  import { PickType } from '@nestjs/mapped-types';
  import { User } from '@users/entities/user.entity';
  import { IsOptional } from 'class-validator';

  export class ValidateAuthInputDto extends PickType(User, ['email', 'password']) {}

  export class ValidateAuthOutputDto extends CoreOutput {
    @IsOptional()
    user?: User;
  }
  ```

3. auth.service.ts 생성

  ```shell
  nest g service auth
  ```

4. Validate User Service 로직 구현

  `src/auth/auth.service.ts`
  ```ts
  import { Injectable } from '@nestjs/common';

  // highlight-next-line
  import { ValidateAuthInputDto, ValidateAuthOutputDto } from '@auth/dtos/validate-auth.dto';
  import { UsersService } from '@users/users.service';

  @Injectable()
  export class AuthService {
    constructor(private readonly usersService: UsersService) {}

    /* Validate User */
    // highlight-start
    async validateUser(validateAuthInputDto: ValidateAuthInputDto): Promise<ValidateAuthOutputDto> {
      try {
        const { email, password } = validateAuthInputDto;
        const { user } = await this.usersService.findOneUser({ email });
        if (!user) return { ok: false, error: '이메일 계정이 존재하지 않습니다.' };
        if (user && user.password !== password) {
          return { ok: false, error: '패스워드가 일치하지 않습니다.' };
        }
        return { ok: true, user };
      } catch (error) {
        return { ok: false, error: '로그인 인증에 실패하였습니다.' };
      }
    }
  }
    // highlight-end
  ```

  usersService의 findOneUser 메서드로부터 user가 있는지 검증, 
  user가 존재한다면 패스워드 입력이 일치했는지 검증한다. 
  검증 도중 에러가 발생하면 `ts$return { ok: false, error: '로그인 인증에 실패하였습니다.' }`를 리턴합니다.