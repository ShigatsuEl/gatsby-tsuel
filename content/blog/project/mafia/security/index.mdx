---
title: NestJS Refresh Token 활용하기
date: 2021-08-02
slug: /blog/project/mafia/security
categories: ['all', 'project']
tags: ['NestJS', 'TypeScript', 'Refresh-Token', 'Access-Token', 'XSS', 'CSRF']
---

[지난 글](/blog/project/mafia/login)에서 `Passport-Local` 전략을 구성해 사용자 이름 / 패스워드를 통한 로그인을 구현해 보았으며 JWT 인증 방식을 더해 로그인 후속조치를 
어떻게 할 것인지도 정했습니다. 한가지 아쉬운 점은 추후에 프론트 쪽에서 앱을 구성할 때, 로그인 상태임에도 불구하고 사이트를 종료하거나 새로고침을 
하게 되면 `accessToken` 정보가 전부 날아가므로 다시 로그인을 해야할 수도 있습니다. accessToken이 데이터베이스로부터 불러오는 것이 아니고 
로컬 데이터 변수로 저장되어 사용될 것이기 때문입니다.

이 문제를 해결하기 위한 방법을 찾기 위해 많은 구글링을 동원하였고 여러 개발자분들이 사용하는 몇가지 방법을 찾게 되었습니다.

1. localStorage 저장 방식

  localStorage는 브라우저가 가지고 있는 작은 저장소로 프론트의 데이터베이스 같은 역할을 합니다. 
  localStorage에 저장된 key / value 쌍은 영구적으로 저장이 된다는 장점이 존재하기 때문에 이곳에 `accessToken`을 저장한다면 
  위에서 언급한 문제(사이트 종료 또는 새로고침 시, accessToken이 날라가는 현상)를 해결할 수 있으므로 좋은 해결방안이 될 수 있습니다.

2. 쿠키 저장 방식

  JWT로 발급한 `accessToken`을 로그인을 통해 쿠키값으로 지정하는 방법입니다. 
  쿠키는 localStorage처럼 영구적으로 저장되지 않고 만료기간이 존재하며 만료기간을 지나면 더이상 사용할 수 없게 됩니다.

> 위 방법 중 어떤 방법이 더 좋을까? :confused:

위 질문의 정답을 도출하기 위해 여러 글을 찾아 읽고 내린 결론은 그 어떠한 방법도 완벽한 인증 방식이 될 수 없다는 것이었습니다. 
위의 두가지 방식의 공통적인 단점은 XSS공격에 대해 좋지 않은 방어태세를 가지고 있습니다. 
악성 클라이언트가 script를 사이트에 삽입하면 localStorage 저장소나 쿠키 저장소에 있는 값을 가져와 언제든지 인증된 사용자인 척 할 수 있기 
때문입니다. 이것은 사용자가 우리의 사이트를 신뢰하는 점을 이용한다고 볼 수 있습니다. 
두번째로 악성 클라이언트가 다른 인증된 사용자로부터 의도치 않은 행동을 유도하여 서버에 요청을 보낼 수 있게하는 CSRF공격에 노출될 수 있다는 점 입니다. 
사용자가 사이트를 신뢰하는 점을 이용한 XSS공격에 반해 이것은 사이트가 사용자를 신뢰한다는 점을 이용한 것이라 할 수 있습니다. 
**이러한 이유로 localStorage 또는 쿠키에 accessToken을 저장하는 방식은 좋지 않을 수 있습니다.**

> 그렇다면 어떠한 방법을 사용해야 한단 말인가?? :sob:

먼저 accessToken을 가지고 인증을 구현했을 상황을 생각해봅시다.
accessToken의 인증 기간을 약 2주동안 설정하였고 해커가 accessToken을 탈취해갔다고 가정해보는 겁니다. 
여기서 생기는 가장 큰 문제는 해커가 accessToken을 가지고 서버에 어떠한 요청을 보내도 막을 방법이 없다는 것 입니다. 
그저 accessToken이 만료되는 기간(2주)동안 해커가 남용하는 상황을 지켜보고 있을 수 밖에 없습니다. 
accessToken의 단점 중 하나가 한번 생성되면 삭제할 수 있는 방법이 없기 때문입니다. 

그래서 accessToken이 탈취될 때를 대비해 accessToken의 만료기간을 굉장히 짧은 기간(5분)으로 설정하려고 합니다. 
짧은 기간이 주어졌기 때문에 설령 5분안에 accessToken을 탈취해간다고 해도 만료가 되는 시점에서 다시 accessToken을 발급 받아야 합니다. 
때문에 accessToken을 탈취 당한 가장 최악의 케이스에도 해커의 공격을 막을 수 있습니다. 
하지만 이번에도 문제가 생겼습니다. 
클라이언트 측에서 서비스를 이용하려고 로그인을 하였지만 인증을 진행한 5분뒤에 accessToken이 만료되어 다시 로그인을 진행해야 하는 상황이 
발생한 것 입니다. 
이는 사용자의 입장에서 별로 좋지 않은 경험을 제공하게 될 것 입니다.

이러한 문제점을 보완하기 위해 생겨난 개념이 refreshToken 입니다. 
refreshToken을 accessToken과 함께 사용하면 accessToken을 짧은 만료주기로 사용을 하면서도 로그인을 계속해서 유지시키는 것을 가능하게 할 수 있습니다. 
지금부터 우리는 accessToken과 함께 refreshToken을 발급받아 로그인을 연장시키도록 해보고 마지막으로 accessToken 단독사용 방법에 비해 어떠한 점이 
좋은지, 안좋은지를 따져보도록 할 것 입니다.

시작하겠습니다. :blush:

## JWT refreshToken 발급 Flow

우선, accessToken 발급이 어떻게 이루어졌는지 짚고 가도록 합시다.

1. 클라이언트가 로그인을 진행하면 JWT에 `Header` | `Payload` | `Signature`등의 정보를 JSON에 담아 서명하여 `access_token`을 발급하여 
  클라이언트에게 제공합니다.

2. 서버로부터 받은 토큰을 요청헤더의 베어러토큰에 제공해 서버에 요청을 하면 서버가 토큰으로부터 유효한 사용자인지 인가(Authorization) 후 토큰을 
  복호화(decode)하여 원래의 payload를 받아 클라이언트에게 `req.user` 형태로 제공하게 됩니다.

3. 따라서 JwtStrategy의 인증을 받은 사용자는 req.user로부터 사용자의 정보를 사용할 수 있게 되며 그렇지 않은 자는 로그인을 거쳐야만 할 것 입니다.

이것이 accessToken의 발급 진행과정 입니다. 
덕분에 클라이언트 측에서 accessToken 발급을 통해 Authorization(인가) 단계를 통과하여 계속해서 내가 로그인해 있음을 서버에 알려줄 수 있게 되는 것이죠. 
하지만 페이지가 새로고침되거나 사이트가 종료하게 되면 우리가 가지고 있던 accessToken은 사라지게 되며 다시 로그인을 요청하여 accessToken을 발급 받아야 합니다. 
그렇지 않으면 어떠한 요청을 보낼 때 요청헤더의 베어러토큰에 accessToken을 실어보낼 수 없게 되며 이는 곧 인증받은 사용자임을 증명할 수 없게 되는 것으로 직결됩니다. 
따라서 우리는 페이지가 새로고침되거나 사이트가 종료되어도 로그인 상태가 유지되어 있음을 서버에게 알려줄 **무언가**가 필요합니다. 
즉, 저장소가 필요한데 브라우저의 저장소로 불리우는 `localStorage` 또는 `쿠키`를 이용해야 하는 것을 의미합니다. 

> 하지만 아까 전에 localStorage, 쿠키를 사용해서 서버에 요청하는 것은 악성 사용자에게 공격(XSS, CSRF)을 허용할 수 있다고 하지 않았나요?

맞습니다! :smiley:

XSS 공격을 당하게 되면 브라우저의 localStorage 그리고 쿠키에 들어있는 값을 빼내어 인증된 사용자인 척 서버에 요청하는 일도 할 수 있게 됩니다. 
따라서 우리는 쿠키 저장소를 이용하되, 조금이나마 공격으로부터 보호할 수 있는 방안을 생각해볼 필요가 있습니다. 
그렇게 되면 우리가 쿠키를 이용해 페이지가 새로고침 되어도 또는 사이트가 종료되어도 accessToken을 계속해서 발급받아 사용할 수 있을 것 입니다. 
그리고 accessToken을 계속해서 발급받기 위해 우리는 하나의 토큰을 더 필요로 하게 되는데 바로 `refreshToken`의 존재 입니다. 
refreshToken의 발급 과정은 아래와 같습니다.

1. 클라이언트가 로그인을 진행하면 JWT를 이용해 `accessToken`과 `refreshToken`을 발급하고 refreshToken을 응답쿠키로 설정하며 accessToken을 
  json 형태로 응답합니다.

2. 그 이후에 클라이언트가 페이지를 새로고침하거나 나가게 되면 쿠키에 담긴 refreshToken을 사용해 accessToken과 refreshToken을 재발급하여 
  refreshToken을 응답쿠키로 설정하고 accessToken을 json 형태로 보내주게 되면서 계속해서 accessToken을 클라이언트 측에서 사용할 수 있도록 
  합니다.

즉, refreshToken의 역할은 accessToken이 만료되거나 accessToken의 사용이 더이상 불가능해질 때 새로 발급하도록 도와주는 역할을 하게 되는 것 입니다.

## JWT refreshToken 발급

이제부터 방금전에 설명한 refreshToken의 발급 Flow를 따라 refreshToken과 accessToken을 생성하는 코드를 작성해 보도록 할 것 입니다. 
바로바로 완벽한 코드를 작성하기 보다 흐름을 이해하면서 중간에 생기는 문제점을 리팩토링하며 설명을 할 예정이오니 코드를 바로 따라치기보다 흐름을 이해하신 
뒤에 코드를 사용하시는 것이 좋을 것 같습니다 :) :grin:

1. 쿠키 설정

  우리는 refreshToken과 accessToken의 발급을 위해 쿠키를 사용할 것으로 정했습니다. 
  그리고 NestJS에서 쿠키를 사용하는 방법은 다음과 같습니다.

  ```shell{outputLines: 3}
  npm install cookie-parser // npm 설치 방식
  npm install -D @types/cookie-parser // npm 설치 방식
  or
  yarn add cookie-parser // yarn 설치 방식
  yarn add -D @types/cookie-parser // yarn 설치 방식
  ```

  `src/main.ts`
  ```ts
  import { ValidationPipe } from '@nestjs/common';
  import { NestFactory } from '@nestjs/core';
  // highlight-next-line
  import * as cookieParser from 'cookie-parser';

  import { AppModule } from '@/app.module';

  async function bootstrap() {
    const app = await NestFactory.create(AppModule);
    app.useGlobalPipes(new ValidationPipe());
    // highlight-next-line
    app.use(cookieParser());
    await app.listen(3000);
  }
  bootstrap();
  ```

2. 환경 변수 추가

  추가해야 하는 환경 변수는 다음과 같습니다. 

  `src/app.module.ts`
  ```
  @Module({
    imports: [
      ConfigModule.forRoot({
        ...
        validationSchema: Joi.object({
          ...
          // highlight-start
          JWT_ACCESS_TOKEN_SECRET_KEY: Joi.string().required(),
          JWT_REFRESH_TOKEN_SECRET_KEY: Joi.string().required(),
          JWT_ACCESS_TOKEN_EXPIRATION_TIME: Joi.string().required(),
          JWT_REFRESH_TOKEN_EXPIRATION_TIME: Joi.string().required(),
          // highlight-end
        }),
      }),
    ],
  })
  export class AppModule {}
  ```

  accessToken과 refreshToken의 secretKey를 다르게 적용하며 발급시간도 다르게 가져야 합니다. 
  보통 refreshToken이 accessToken의 만료기간보다 길어야 합니다. 
  그래야 refreshToken을 가지고 accessToken을 발급 받을 수 있게 됩니다. 
  정해진 기간은 따로 없지만 accessToken은 1시간, refreshToken은 2주 정도로 잡는 듯 합니다. 
  딱히 똑같이 지정할 필요는 없으며 저 역시 실제로는는 다른 시간으로 잡아줄 것 입니다. 
  위 코드에서는 accessToken은 1시간, refreshToken은 2주로 잡아주는 것을 예시로 들 것이며 `1h`, `14 days`로 설정하도록 하겠습니다.

3. 로그인 구현

  accessToken + refreshToken을 함께 발급 받도록 코드 수정

  `src/auth/auth.service.ts`
  ```ts{numberLines: true}
  @Injectable()
  export class AuthService {
    ...
    /* Login Service */
    async login(res: Response, loginAuthInputDto: LoginAuthInputDto): Promise<LoginAuthOutputDto> {
      try {
        const { ok, error, data } = loginAuthInputDto;

      // 로그인 상태 확인
        if (ok === false) return { ok: false, error };
        if (data == null) return { ok: false, error: '토큰을 발급 받을 수 없습니다.' };

        // refreshToken & accessToken 재발급
        // highlight-start
        const { id } = data;
        const payload = { id };
        const accessToken = this.jwtService.sign(payload, {
          secret: this.configService.get('JWT_ACCESS_TOKEN_SECRET_KEY'),
          expiresIn: +this.configService.get('JWT_ACCESS_TOKEN_EXPIRATION_TIME'),
        });
        const refreshToken = this.jwtService.sign(payload, {
          secret: this.configService.get('JWT_REFRESH_TOKEN_SECRET_KEY'),
          expiresIn: +this.configService.get('JWT_REFRESH_TOKEN_EXPIRATION_TIME'),
        });
        // highlight-end

        // 쿠키 설정
        // highlight-start
        res.cookie('refreshToken', refreshToken, {
          expires: new Date(Date.now() + +this.configService.get('JWT_REFRESH_TOKEN_EXPIRATION_TIME')),
          httpOnly: true,
        });
        // highlight-end
        return {
          ok: true,
          // highlight-next-line
          accessToken,
        };
      } catch (error) {
        console.log(error);
        return { ok: false, error: '로그인 인증에 실패하였습니다.' };
      }
    }
  }
  ```

  `src/auth/auth.controller.ts`
  ```ts
  import { Controller, Post, Req, Res, UseGuards } from '@nestjs/common';
  ...

  export class AuthController {
    /* Post Login Controller */
    @UseGuards(LocalAuthGuard)
    @Post('login')
    // highlight-start
    async login(@Req() req: RequestWithUser, @Res({ passthrough: true }) res: Response): Promise<LoginAuthOutputDto> {
      return this.authService.login(res, req.user);
    }
    // highlight-end
  }
  ```

  로그인 진행 시, req.user의 값을 확인함으로써 로그인이 제대로 이루어졌는지 확인합니다. 
  이후 accessToken과 refreshToken을 발급하고 refreshToken은 쿠키로, accessToken은 json형태로 응답하도록 합니다. 

  (참고) 27, 28번 라인을 살펴보면 쿠키를 적용할 때 옵션을 줄 수 있는데 expires는 알다시피 만료기간을 정하는 속성이고 httpOnly 속성이 무엇인지 궁금하실텐데 
  이는 XSS공격을 방어할 수 있는 수단으로 만약에 해커가 자바스크립트를 삽입해 쿠키를 탈취하려는 시도가 발생할 때 접근할 수 없도록 막아주는 역할을 하게 됩니다. 
  하지만 XSS 공격 수단이 주어진다면 쿠키 하이재킹이 이루어져 탈취될 가능성이 있다고 하니 따로 XSS 보안을 구축하는 것이 좋을 것 같습니다. 
  그리고 https에서만 쿠키를 가져올 수 있게 하는 secure 옵션도 적용할 것이지만 지금은 로컬환경에서 개발중이므로 나중에 배포할 때 적용해주는 것도 
  좋은 방법일 듯 합니다.

  추후에 프론트에서는 accessToken을 사용해 인가를 받아 로그인 상태임을 확인받으며 필요하다면 쿠키에 담긴 refreshToken을 서버로 보내 
  쿠키에 담긴 refreshToken값이 유효한지 확인하고 accessToken과 refreshToken을 재발급 받는 과정도 해볼 것 입니다.

이제 여기까지 해본 것을 테스트 해보도록 합시다.

- 로그인 테스트 결과

![Login Test Result](./gatsby-project-mafia-security-01.PNG 'Login Test Result')

accessToken을 성공적으로 발급했습니다. :grin:

![Login Test Result](./gatsby-project-mafia-security-02.PNG 'Login Test Result')

응답쿠키로 refreshToken을 성공적으로 발급했습니다. :grin:

![Cookie](./gatsby-project-mafia-security-03.PNG 'Cookie')

refreshToken을 쿠키에 저장하였습니다. :grin:

## Silent Refresh

이번에 생각해볼 것은 로그인 이후에 페이지가 새로고침되거나 사이트가 종료될 때 어떻게 처리해야할까를 생각해봅시다. 
만약 페이지가 새로고침되거나 사이트가 종료된 후 다시 접속하게 되었을 때 accessToken을 잃어버리지 않도록 해야합니다. 
하지만 실제로 accessToken을 붙잡는 것은 불가능하며 대신에 accessToken을 재발급하여 사용하는 방법을 사용하도록 해야 합니다. 
accessToken을 재발급 하기 위해 필요한 것이 바로 `refreshToken`이며 페이지가 리프레시 될 때 refreshToken을 조용히 서버에 전송해 accessToken을 
재발급받는 방법을 `Silent Refresh`라고 명칭하는 듯 합니다. 
로그인을 한지 오랜시간이 되었는데도 다시 접속했을 때 로그인이 유지되어 있는 경우를 경험하신 적이 있나요? 
바로 그러한 경우가 해당이 됩니다. 
만약 페이지가 새로고침되거나 사이트가 종료될 때 `silent-refresh` API를 서버에 전송할 수 있다면 그 이후에도 accessToken을 접근할 수 있지 않을까요?

따라서 우리는 accessToken과 refreshToken을 재발급 받을 수 있는 Silent Refresh 로직을 구현해 보도록 할 것 입니다.

1. Dto 생성

  :heavy_plus_sign: `src/auth/dtos/silent-refresh-auth.dto.ts`
  ```ts
  import { CoreOutput } from '@common/dtos/core.dto';
  import { IsOptional, IsString } from 'class-validator';

  export class SilentRefreshAuthOutputDto extends CoreOutput {
    @IsOptional()
    @IsString()
    accessToken?: string;
  }
  ```

2. Silent Refresh 로직 구현

  `src/auth/auth.service.ts`
  ```ts
  @Injectable()
  export class AuthService {
    ...
    /* Silent Refresh Service */
    async silentRefresh(req: Request, res: Response): Promise<SilentRefreshAuthOutputDto> {
      try {
        // refreshToken 유효성 검사
        // highlight-start
        const getRefreshToken = req.cookies['refreshToken'];
        if (!getRefreshToken) return { ok: false, error: '쿠키를 가지고 있지 않습니다.' };
        const refreshTokenPayload: RefreshTokenPayload = await this.jwtService.verify(getRefreshToken, {
          secret: this.configService.get('JWT_REFRESH_TOKEN_SECRET_KEY'),
        });
        // highlight-end

        // refreshToken & accessToken 재발급
        const payload = { id: refreshTokenPayload.id };
        const accessToken = this.jwtService.sign(payload, {
          secret: this.configService.get('JWT_ACCESS_TOKEN_SECRET_KEY'),
          expiresIn: +this.configService.get('JWT_ACCESS_TOKEN_EXPIRATION_TIME'),
        });
        const refreshToken = this.jwtService.sign(payload, {
          secret: this.configService.get('JWT_REFRESH_TOKEN_SECRET_KEY'),
          expiresIn: +this.configService.get('JWT_REFRESH_TOKEN_EXPIRATION_TIME'),
        });

        // 쿠키 설정
        res.cookie('refreshToken', refreshToken, {
          expires: new Date(Date.now() + +this.configService.get('JWT_REFRESH_TOKEN_EXPIRATION_TIME')),
          httpOnly: true,
        });
        return {
          ok: true,
          accessToken,
        };
      } catch (error) {
        return { ok: false, error: '로그인 연장에 실패하였습니다.' };
      }
    }
  }
  ```

  `src/auth/auth.controller.ts`
  ```ts
  import { Controller, Post, Req, Res, UseGuards } from '@nestjs/common';
  import { Request, Response } from 'express';

  export class AuthController {
    ...

    /* Post Silent Refresh Controller */
    // highlight-start
    @Post('silent-refresh')
    async silentRefresh(@Req() req: Request, @Res({ passthrough: true }) res: Response) {
      return this.authService.silentRefresh(req, res);
    }
    // highlight-end
  }
  ```

  Silent Refresh 서비스는 로그인 서비스와 굉장히 유사한 구조를 가지고 있습니다. 
  한가지 다른점은 쿠키에서 refreshToken값을 가져와 그 값이 유효한지 확인하는 것 입니다. 
  만약 refreshToken이 디코딩되었을 때 유효하지 않다면 누군가가 refreshToken을 탈취해 값을 바꿧다는 의미가 되며 accessToken과 refreshToken의 재발급을 
  하지 않고 에러를 반환하도록 하는 것 입니다. 
  반대로 refreshToken값이 유효하다면 accessToken과 refreshToken을 생성해 다시 쿠키와 json형태로 응답해주게 됩니다.

  이러한 형태의 토큰 발급 패턴은 어떠신가요? :smile:
  현재 실질적으로 인증되었는지를 결정하는 것은 accessToken입니다. 
  하지만 악성 사용자가 접근할 수 있는 값은 쿠키에 저장되어 있는 refreshToken값으로 accessToken에 바로 접근할 수 없습니다. 
  따라서 accessToken을 얻을 수 있는 방법은 오로지 로그인 또는 silent-refresh API를 통해 accessToken을 재발급 받는 방법 뿐 입니다.

이제 Silent Refresh를 테스트 해보겠습니다.

- Silent Refresh 성공

![Silent Refresh Result](./gatsby-project-mafia-security-04.PNG 'Silent Refresh Result')

accessToken을 성공적으로 재발급했습니다. :grin:

![Silent Refresh Result](./gatsby-project-mafia-security-05.PNG 'Silent Refresh Result')

응답쿠키로 refreshToken을 성공적으로 재발급했습니다. :grin:

![Cookie](./gatsby-project-mafia-security-06.PNG 'Cookie')

refreshToken을 쿠키에 저장하였습니다. :grin:

- Silent Refresh 실패

실패했을 때를 가정해보도록 합시다. 
만약 누군가 refreshToken의 값을 탈취해 고의적으로 수정하였을 때 결과가 어떻게 출력되는지 확인해 볼까요?

![Silent Refresh Result](./gatsby-project-mafia-security-07.PNG 'Silent Refresh Result')

조금 전에 Silent Refresh를 성공하고 받은 refreshToken값을 임의로 바꾸고 저장합니다.

![Silent Refresh Result](./gatsby-project-mafia-security-08.PNG 'Silent Refresh Result')

refreshToken값을 변경하니 에러를 받았습니다. :persevere: