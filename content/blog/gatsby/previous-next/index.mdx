---
title: [Gatsby] Previous & Next 포스트 기능 구현하기
date: 2021-07-13
slug: /blog/gatsby/previous-next
categories: ['all','gatsby']
---

블로그 글을 읽고 난 후 다음 글을 보고 싶다거나 이전 글을 확인하고 싶은 경우가 종종 생깁니다.

우리가 지금까지 빌드한 Gatsby 프로젝트에서는 이를 위해 `/blog`로 돌아와 블로그 리스트에서 글을 다시 선택해야 합니다.

굉장히 귀찮습니다. :weary:

만약 글의 마지막에 이전 포스트와 다음 포스트의 링크를 둘 수 있다면? :open_mouth:

시작해보겠습니다.

## Previous & Next 포스트 경로를 어떻게 구현할 수 있을까?

정답은 `gatsby-node.js` 안에 숨어 있습니다.

createPages 메서드 내에서 다음과 같이 수정해봅시다.

`gatsby-node.js`
```js
exports.createPages = async ({ actions, graphql }) => {
  const { createPage } = actions;
  const result = await graphql(`
    query {
      allMdx(sort: { order: DESC, fields: [frontmatter___date] }, limit: 2000) {
        edges {
          next {
            fields {
              slug
            }
            frontmatter {
              title
            }
          }
          node {
            fields {
              slug
            }
            frontmatter {
              categories
            }
          }
          previous {
            fields {
              slug
            }
            frontmatter {
              title
            }
          }
        }
      }
    }
  `);

  result.data.allMdx.edges.forEach(({ next, node, previous }) => {
    createPage({
      path: node.fields.slug,
      component: path.resolve(`./src/templates/blog-post.tsx`),
      context: {
        next,
        slug: node.fields.slug,
        previous,
      },
    });
  });
};
```

Previous와 Next는 allMdx 또는 allMarkdownRemarks 내의 edges :point_right: next & previous에서 찾아볼 수 있습니다.

우리는 previous와 next를 createPage의 context 속성으로 부여할 것 입니다.

한가지 더 중요한 사실은 allMdx에서 반드시 정렬을 해야한다는 것 입니다.

`allMdx(sort: { order: DESC, fields: [frontmatter___date] })`

:point_up:

위는 allMdx를 `frontmatter___date` 필드를 기준으로 내림차순으로 정렬하는 것을 의미합니다.

정렬이 되어있지 않다면 previous와 next가 무의미해지며 순서를 잘못 잡을수도 있습니다.