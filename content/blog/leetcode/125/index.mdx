---
title: Valid Palindrome
date: 2021-07-15
slug: /blog/leetcode/125
categories: ['all', 'leetcode']
tags: ['Python','String']
---

주어진 문자열이 팰린드롬인지 확인하는 문제이다. 대소문자를 구분하지 않으며, 영문자와 숫자만을 대상으로 한다.

(팰린드롬이란 앞뒤가 똑같은 단어 또는 문장으로 뒤집어도 똑같은 모양새를 하는 단어나 문장을 뜻합니다)

`Example 1:`
```
Input: s = "A man, a plan, a canal: Panama"
Output: true
Explanation: "amanaplanacanalpanama" is a palindrome.

```

`Example 2:`
```
Input: s = "race a car"
Output: false
Explanation: "raceacar" is not a palindrome.
```

`Constraints:`
```
1 <= s.length <= 2 * 105
s consists only of printable ASCII characters.
```

## 알고리즘 설계

1. 제약조건에 대소문자 구분없는 문자열로만 구성하는 것이 주어져 있으므로 그에 대한 전처리를 한다.

2. 전처리가 완료된 문자열을 리스트에 담은 후, 리스트의 길이가 1 이하가 되기전까지 리스트의 첫번째 인덱스와 마지막 인덱스가 같은지 확인하도록 한다.

3. while문이 종료할 때까지 첫번째 인덱스와 마지막 인덱스가 같다면 **True**를 반환하고 그렇지 않다면 **False**를 반환한다.

## 작성한 코드

```python{numberLines: true}
class Solution:
    def isPalindrome(self, s: str) -> bool:
        strs = []
        for char in s:
            if char.isalnum():
                strs.append(char.lower())
        
        while len(strs) > 1:
            if strs.pop(0) != strs.pop():
                return False
        return True
```

## 다른 방법

`Another Answer 1:`

파이썬에서 제공하는 Deque 자료구조를 사용한다. 알고리즘 순서는 이전과 같으나 pop을 하는 단계에서 처리속도가 차이가 나게 된다.
Deque는 앞에서 제거하는데 O(1)의 시간이 걸리는데 비해 list는 O(n)의 시간이 걸리기 때문이다.

```python{numberLines: true}
import collections
from typing import Deque


class Solution:
    def isPalindrome(self, s: str) -> bool:
        strs: Deque = collections.deque()

        for char in s:
            if char.isalnum():
                strs.append(char.lower())

        while len(strs) > 1:
            if strs.popleft() != strs.pop():
                return False

        return True
```

`Another Answer 2:`

정규표현식을 사용해 제약조건을 만족시킵니다. 그리고 pop() 메서드를 사용하지 않고 슬라이싱 step을 사용하여 문자열을 뒤집은 것과 
문자열이 같은지 확인하여 참, 거짓을 반환합니다.

```python{numberLines: true}
import re


class Solution:
    def isPalindrome(self, s: str) -> bool:
        s = s.lower()
        # 정규식으로 불필요한 문자 필터링
        s = re.sub('[^a-z0-9]', '', s)

        return s == s[::-1]  # 슬라이싱
```