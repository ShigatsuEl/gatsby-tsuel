---
title: Design Circular Queue(원형 큐 구현)
date: 2021-07-22
slug: /blog/leetcode/622
categories: ['all', 'leetcode']
tags: ['Python', 'Queue']
---

원형 큐를 구현하세요.

- MyCircularQueue(k) Initializes the object with the size of the queue to be k.

- int Front() Gets the front item from the queue. If the queue is empty, return -1.

- int Rear() Gets the last item from the queue. If the queue is empty, return -1.

- boolean enQueue(int value) Inserts an element into the circular queue. Return true if the operation is successful.

- boolean deQueue() Deletes an element from the circular queue. Return true if the operation is successful.

- boolean isEmpty() Checks whether the circular queue is empty or not.

- boolean isFull() Checks whether the circular queue is full or not.

`Example 1:`
```
Input
["MyCircularQueue", "enQueue", "enQueue", "enQueue", "enQueue", "Rear", "isFull", "deQueue", "enQueue", "Rear"]
[[3], [1], [2], [3], [4], [], [], [], [4], []]
Output
[null, true, true, true, false, 3, true, true, true, 4]

Explanation
MyCircularQueue myCircularQueue = new MyCircularQueue(3);
myCircularQueue.enQueue(1); // return True
myCircularQueue.enQueue(2); // return True
myCircularQueue.enQueue(3); // return True
myCircularQueue.enQueue(4); // return False
myCircularQueue.Rear();     // return 3
myCircularQueue.isFull();   // return True
myCircularQueue.deQueue();  // return True
myCircularQueue.enQueue(4); // return True
myCircularQueue.Rear();     // return 4
```

`Constraints:`
```
1 <= k <= 1000
0 <= value <= 1000
At most 3000 calls will be made to enQueue, deQueue, Front, Rear, isEmpty, and isFull.
```

## 알고리즘 설계

1. enQueue는 마지막 인덱스가 비어있는지 확인하고 비어있다면 푸시한다.

2. deQueue는 첫번째 인덱스가 비어있는지 확인하고 비어있지 않다면 제거한다.

3. Front와 Rear는 첫번째 인덱스와 마지막 인덱스가 비어있지 않다면 인덱스에 해당하는 값을 반환하고 비어있다면 -1을 반환한다.

4. isEmpty는 front와 rear가 같고 둘의 값 중 아무나 None이면 True를 반환, isFull은 front와 rear가 같고 둘의 값 중 아무나 None이 아니면 True를 반환한다.

## 작성한 코드

```python{numberLines: true}
class MyCircularQueue:

    def __init__(self, k: int):
        self.q = [None] * k
        self.maxlen = k
        self.front = 0
        self.rear = 0
        

    def enQueue(self, value: int) -> bool:
        if self.q[self.rear] is None:
            self.q[self.rear] = value
            self.rear = (self.rear + 1) % self.maxlen
            return True
        else:
            return False
        

    def deQueue(self) -> bool:
        if self.q[self.front] is None:
            return False
        else:
            self.q[self.front] = None
            self.front = (self.front + 1) % self.maxlen
            return True

    def Front(self) -> int:
        return -1 if self.q[self.front] is None else self.q[self.front]
        
    def Rear(self) -> int:
        return -1 if self.q[self.rear - 1] is None else self.q[self.rear - 1]

    def isEmpty(self) -> bool:
        return self.front == self.rear and self.q[self.front] is None
        
    def isFull(self) -> bool:
        return self.front == self.rear and self.q[self.front] is not None
```